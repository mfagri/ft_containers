// Implementing Red-Black Tree in C++

#include <iostream>
using namespace std;

template <typename value_type,typename size>

struct Node_struct {

  value_type data;
  Node_struct<value_type,size> *parent;
  Node_struct<value_type,size> *left;
  Node_struct<value_type,size> *right;
  char color;
  
  Node_struct(value_type d):data(d)
  {
    left = right = parent = nullptr;
	  color = 'r';
  }
};
 


template<typename key_type,class T,typename key_compare,typename size_type,typename Allocator >

class RedBlackTree 
{
  public:
        
    typedef Allocator allocator_type;
    typedef T value_type;
    key_compare key_compare_; // key_compare_(); lambda object convet to function will call operator() (const value_type& x, const value_type& y) const
    typedef Node_struct<T,size_type> Node;
    typedef typename allocator_type::template rebind<Node >::other node_allocator; 
    node_allocator alloc;
    Node * root;
    Node * tmp;
    Node * end_node;
        
    RedBlackTree() 
    {
      tmp = nullptr;
      
      root = nullptr;
      
      Node tmp1((T()));
      end_node = alloc.allocate(sizeof(Node));
      alloc.construct(end_node,tmp1);
    }

    void leftRotate(Node * x) 
    {
      Node * y;
      y = x->right;
      x->right=y->left;
      if(y->left != NULL)
        y->parent->left=x;
      
      y->parent=x->parent;
      if(x->parent==NULL)
        root=y;
      
      else if((x->parent->left != NULL) && (x->data==x->parent->left->data))
        x->parent->left=y;
      
      else
        x->parent->right=y;
      y->left = x;
      x->parent = y;
    }

void rightRotate(Node * y) 
{
	Node * x;
	
	x = y->left;
	y->left=x->right;
	if (x->right != NULL)
	 	x->right->parent = y; 
	x->parent =y->parent;
	if (y->parent == NULL)
		root = x;
	else if ((y->parent->left != NULL) && (y->data == y->parent->left->data))
		y->parent->left = x;

	else
		y->parent->right = x;
	
	x->right = y;
	y->parent = x;
	return;
}

void fixViolation(Node * z) 
{
	Node * y = nullptr;
	while ((z->parent != nullptr) && (z->parent->color == 'r')) 
	{
  	if ( (z->parent->parent->left != nullptr) && (z->parent->data == z->parent->parent->left->data))
		{          
			if(z->parent->parent->right!= nullptr)
				y = z->parent->parent->right;
			if ((y != nullptr) && (y->color == 'r'))
			{
				z->parent->color = 'b';
				y->color = 'b';
				z->parent->parent->color = 'r';
				if(z->parent->parent != nullptr)
					z = z->parent->parent;
			}
			else 
			{
				if ((z->parent->right != nullptr) && (z->data == z->parent->right->data)) 
				{          
					z = z->parent;
					leftRotate(z);
				}
				z->parent->color = 'b';
				z->parent->parent->color = 'r';
				rightRotate(z->parent->parent);
			}
		}
		else 
		{
			if(z->parent->parent->left!=nullptr)
				y = z->parent->parent->left;
			if ((y!=nullptr) && (y->color == 'r')) 
			{
					z->parent->color = 'b';
				y->color = 'b';
				z->parent->parent->color = 'r';
				if(z->parent->parent!=nullptr)
				z = z->parent->parent;
			}
			else 
			{
				if ((z->parent->left != nullptr) && (z->data == z->parent->left->data)) 
				{          
					z = z->parent;
					rightRotate(z);
				}
				z->parent->color = 'b';
				z->parent->parent->color = 'r';	
				leftRotate(z->parent->parent);
			}
		}
		
	}    
	root->color = 'b';
}
  Node * insert_(value_type data) 
  {
    Node * x;
    Node * y;
    Node tmp(data);
    Node * z = alloc.allocate(sizeof(Node));
    alloc.construct(z,tmp);

    x=root;
    
    if ( root == nullptr ) 
    {
      root = z;
      root->color = 'b';
    end_node->left = root;

      root->parent = end_node;

      return root;
    }
    while ( x != nullptr) 
    {
      y = x;
      if ( z->data < x->data) 
        x = x->left;
      else
      x = x->right;
    }
    z->parent = y;
    if ( y == nullptr) 
      root=z;
    else if( z->data < y->data ) 
      y->left = z;
    else
      y->right=z;
    fixViolation(z);
    return root;    
  }

  void insert(value_type val)
  {
    root = insert_(val);
  }
  Node * minValue(Node * node)
  {
      Node * current = node;
      if(!current)
        return nullptr;
      while (current->left != nullptr) 
        current = current->left;
      
      return current;
  }
   Node *search(Node* root, const key_type & key) const // search() const because key_type is const
    {
        if (root == nullptr || (!key_compare_(root->data.first, key) && !key_compare_(key,root->data.first)))// because key_compare_ return < and convert it to ==
            return root;
          
        if (key_compare_(root->data.first, key))
            return search(root->right, key);        
        return search(root->left, key);
    }

    Node * findNodeByK(Node *root, key_type k) 
      {
         Node* x = root;
         Node* y = end_node;
      
          while (x != 0 && x->left != x && x != x->right)
          {
              if (key_compare_(x->data.first, k))
                  x = x->right;
              else
                  y = x, x = x->left;
          }
          return y;
      }
    void printInorder( Node* node)
    {
        if (node == nullptr)
          return;
    
        /* first recur on left child */
        printInorder(node->left);
    
        /* then print the data of node */
        cout << node->data.first << " " << endl;
    
        /* now recur on right child */
        printInorder(node->right);
    }
};

