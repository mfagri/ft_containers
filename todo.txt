
â€¢ std::pair
///////////
check all;
starct node ,countent, color, right, left, parent
https://www.youtube.com/watch?v=WTa3jZKo7ZY

 Now, the question arises that why do we require a Red-Black tree if AVL is also a height-balanced tree. The Red-Black tree is used because the AVL tree requires many rotations when the tree is large

	
	


value_compare	Nested function class to compare elements	see value_comp

iterator	a bidirectional iterator to value_type	convertible to const_iterator
const_iterator	a bidirectional iterator to const value_type	
reverse_iterator	reverse_iterator<iterator>	
const_reverse_iterator	reverse_iterator<const_iterator>
//////////////
*a = t
*a++

*a--

Compare
A binary predicate that takes two element keys as arguments and returns a bool. The expression comp(a,b), where comp is an object of this type and a and b are key values, shall return true if a is considered to go before b in the strict weak ordering the function defines.
The map object uses this expression to determine both the order the elements follow in the container and whether two element keys are equivalent (by comparing them reflexively: they are equivalent if !comp(a,b) && !comp(b,a)). No two elements in a map container can have equivalent keys.
This can be a function pointer or a function object (see constructor for an example). This defaults to less<T>, which returns the same as applying the less-than operator (a<b).
Aliased as member type map::key_compare.




typedef _T1 first_type;
        typedef _T2 second_type;
        
        first_type first;
        second_type second;

        pair() : first(), second() {}
        pair(first_type const &_t1, second_type const &_t2) : first(_t1), second(_t2) {}

        template <class _U1, class _U2>
        pair(const pair<_U1, _U2>& _rhs) : first(_rhs.first), second(_rhs.second) {}
        
        pair& operator=(const pair& _rhs)
        {
            first = _rhs.first;
            second = _rhs.second;
            return (*this);
        }
        void swap(pair& _rhs)
        {
            std::swap(first,  _rhs.first);
            std::swap(second, _rhs.second);
        }





1
2
3
3
2
0
0
4
4
4
1
3
3
2
4
////
1
2
3
3
2
3
0
4
4
4
1
3
3
2
4